import os
import numpy as np 
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
from math import floor

path = "C:\\Users\\janva\\Desktop\\ERDA\\pre-processing\\traindata"
pathtoresults = "C:\\Users\\janva\\Desktop\\ERDA\\pre-processing\\results\\"

#Load the images as paths
def loadImages(path):
    files = os.listdir(path)

    for i in range(len(files)):
        f = os.path.join(path, files[i])
        files[i] = f

    return files

#function to perform the final resize of the pictures including cutting the plane out for the color images
def resizeF(img, commonheight, commonwidth, dim, orSize, edges, ed):
    #remove the alpha channel
    img = cv2.cvtColor(img, cv2.COLOR_RGBA2RGB)
    
    #Determine the size of the picture that keeps the original ratio but fits in the final image
    factorh = commonheight / orSize[0]
    factorw = commonwidth / orSize[1]
    resh = (int(factorh * orSize[0]),int(factorh * orSize[1]))
    resw = (int(factorw * orSize[0]),int(factorw * orSize[1]))

    #check whether the width or the height of the picture is completely filled with the original in the final size
    option = -1
    if resh[1] < commonwidth:
        height = resh[0]
        width = resh[1]
        option = 1
    else:
        height = resw[0]
        width = resw[1]
        option = 2

    #store the new dimension of the picture and resize the images to the sizes determined
    dim = (width, height)
    img = cv2.resize(img,dim,interpolation=cv2.INTER_LINEAR)
    edges = cv2.resize(edges,dim,interpolation=cv2.INTER_LINEAR)

    #if the picture has to be resized with the grabcut function, this will be done in this section
    if not ed:
        #determine the minimum and maximum position of the edges
        mini = dim[1]
        maxi = 0
        minj = dim[0]
        maxj = 0
        for i in range(len(edges)):
            #print(i)
            for j in range(len(edges[1])):
                if edges[i][j] != 0:
                    if i > maxi:
                        maxi = i
                    if i < mini:
                        mini = i
                    if j < minj:
                        minj = j
                    if j > maxj:
                        maxj = j

        mask = np.zeros(img.shape[:2],np.uint8)
        bgdModel = np.zeros((1,65), np.float64)
        fgdModel = np.zeros((1,65), np.float64)
        rect = (minj, mini, maxj-minj, maxi-mini)       #the found rectangle
        
        #perform the grabcut operation with the found rectangle from the edge image
        cv2.grabCut(img,mask,rect,bgdModel,fgdModel,5,cv2.GC_INIT_WITH_RECT)
        mask2 = np.where((mask==2)|(mask==0),0,1).astype('uint8')
        #set up the new image, generated by the grabcut operation
        newImg = img * mask2[:,:,np.newaxis]
    else:
        newImg = img
    
    #The image must be put in an image with the same length and with to be able to input it in the NN. This will be done in this last part of this function
    #store the old image
    partIm = newImg
    #setup an array for the final image
    resizedIm = np.zeros((commonheight, commonwidth, 3),dtype=np.uint8)
    #It depends on the original image size, which side already has the total length, where to position it in the final array
    if option == 1:
        start = int((len(resizedIm[1]))/2-dim[0]/2)
        resizedIm[0:dim[1], start:start + dim[0]] = partIm
    else:
        start = int((len(resizedIm))/2-dim[1]/2)
        resizedIm[start : start + dim[1], 0:dim[0]] = partIm
    newsize = (commonheight, commonwidth)
    #return the final resized image
    return resizedIm


#IMPORTANT PART
#preprocessing
def processing(data, path, pathtoresults):
    #the parameters of the sizes of the images that this algorithm should output. This needs to be the same for all pictures to be able to input it in the NN.
    ratio = 16 / 9
    commonheight =  150                           #px
    commonwidth = int(ratio * commonheight)      #px

    #loading the images from the names inputted in the function
    img = []
    titles = []
    for i in data:
        simg = cv2.imread(i,cv2.IMREAD_UNCHANGED)
        #simg = cv2.cvtColor(simg, cv2.COLOR_BGR2RGB)
        img.append(simg)
        titles.append(i[len(path)+1::])

    #for every image inputted, the same operations apply, these are done in the next for loop
    for imgind in range(len(img)):
        #store the original size of the picture and the factor how many times larger with respect to the final size, the image should be processed.
        orSize = img[imgind].shape
        sizefactor = 2

        #Resize the image to the processing size determined by the sizefactor and store the new size
        newsize = (int(commonheight * sizefactor), int(orSize[1]/orSize[0]*commonheight*sizefactor))
        dim = (newsize[1], newsize[0])
        res_img = cv2.resize(img[imgind],dim,interpolation=cv2.INTER_LINEAR)

        #Perform the canny edge detection algorithm. To do this, the image is converted to gray scale and blurred to remove the noise.
        gray = cv2.cvtColor(res_img, cv2.COLOR_BGR2GRAY)
        gray = cv2.medianBlur(gray, 9)
        edges = cv2.Canny(gray, 150, 200)

        #Sometimes, there were image with a logo in the lower part of the image. If the amount of edges detected in the block of 40x40 in the lowest row is less then 300, these pixels are removed.
        block = 40
        amount = floor(dim[0] / block)
        maximum = 300
        
        #remove the pixels
        for i in range(amount):
            blockp = edges[dim[1]-block-1 : dim[1]-1, i*block : (i+1)*block]
            total = blockp.sum()
            n = total / 255
            if n < maximum and n != 0:
                blockn = np.zeros((block, block))
                edges[dim[1]-block-1 : dim[1]-1, i*block : (i+1)*block] = blockn
       
        #call the function to perform the final resize of the images including the grabcut operation for the color image
        edgesF = resizeF(edges, commonheight, commonwidth, dim, newsize, edges, 1)
        colorF = resizeF(res_img, commonheight, commonwidth, dim, newsize, edges, 0)

        #Determine the new paths of the images generated. They will only be stored with their number.
        ext = titles[imgind][-4::]
        number = ''
        cont = 1
        ind = 0
        while cont:
            char = titles[imgind][ind]
            if char == '_':
                cont = 0
            else:
                number += char
                ind += 1

        #setup the paths where the images should be stored
        pathfilec = pathtoresults + '\\color\\' + number + ext
        pathfilee = pathtoresults + '\\edge\\' + number + ext

        #write the images in the determined location
        cv2.imwrite(pathfilee, edgesF)
        cv2.imwrite(pathfilec, colorF)


traindata = loadImages(path)
processing(traindata, path, pathtoresults)
